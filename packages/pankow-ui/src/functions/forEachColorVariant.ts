import { ParsedConfig } from "../types/parsedConfig";
import { css } from "./css";

/**
 * Each color variant that is supposed to lead to a dedicated component.
 *
 * @example
 *    ${forEachColorVariant(
 *     config.colorSystem.colors,
 *     ({ name, bgColor, textColor }) =>
 *     .alert-${name} {
 *         @apply bg-${bgColor} text-on-${textColor};
 *       }
 *  )}
 */
export function forEachColorVariant(
  colorSystem: ParsedConfig["colorSystem"],
  callback: (value: { name: string }) => string
): string {
  // only accent and semantic colors are considered to by
  // component variants. Other, auto-generated colors
  // are not considered.
  const colors = Object.keys({
    ...colorSystem.accentColors,
    ...colorSystem.semanticColors,
  });
  // manually adding the surface variants which
  // are autogenerated from the primary color
  // (thus excluded form the above list)
  colors.push(
    ...[
      "surface-100",
      "surface-200",
      "surface-300",
      "surface-400",
      "surface-500",
    ]
  );
  return colors
    .map((name) => {
      const result = callback({ name });
      const applies = css(result)["@apply"];
      // TODO postprocess the applies.
      // to modify the css surfaces

      // "text-on-surface-100" etc. do not exist.
      // therefore, need to manually interfer with the color
      if (name.includes("surface")) {
        return callback({ name, bgColor: name, textColor: "surface" });
      }
      return callback({ name, bgColor: name, textColor: name });
    })
    .join("\n");
}
